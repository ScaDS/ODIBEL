import click
import sys
from typing import Optional
from .rdf_cmd import rdf_cmd
from .source.wikidata_cmd import wikidata_cmd
@click.group()
@click.version_option(version="0.1.0", prog_name="pyodibel")
@click.option(
    "--config", 
    "-c", 
    type=click.Path(exists=True), 
    help="Path to configuration file"
)
@click.option(
    "--verbose", 
    "-v", 
    is_flag=True, 
    help="Enable verbose output"
)
@click.option(
    "--quiet", 
    "-q", 
    is_flag=True, 
    help="Suppress output except errors"
)
@click.pass_context
def cli(ctx: click.Context, config: Optional[str], verbose: bool, quiet: bool):
    """
    KGbench - Knowledge Graph Benchmarking Framework
    
    A comprehensive framework for benchmarking knowledge graph tools
    and creating reproducible pipelines.
    """
    # Ensure context object exists
    ctx.ensure_object(dict)
    
    # Store global options in context
    ctx.obj["config"] = config
    ctx.obj["verbose"] = verbose
    ctx.obj["quiet"] = quiet
    
    # Set up logging level
    if quiet:
        ctx.obj["log_level"] = "ERROR"
    elif verbose:
        ctx.obj["log_level"] = "DEBUG"
    else:
        ctx.obj["log_level"] = "INFO"

cli.add_command(rdf_cmd)
cli.add_command(wikidata_cmd)


@cli.command()
@click.option(
    "--shell",
    "-s",
    type=click.Choice(["bash", "zsh", "fish"], case_sensitive=False),
    default="bash",
    help="Shell type for completion script"
)
@click.option(
    "--output",
    "-o",
    type=click.Path(),
    help="Output file path (default: stdout)"
)
def completion(shell: str, output: Optional[str]):
    """
    Generate shell completion script.
    
    Click uses environment variable-based completion. This command generates
    a shell script that sets up tab completion for pyodibel.
    
    Examples:
    
        # Generate bash completion
        pyodibel completion --shell bash > ~/.pyodibel-complete.bash
        echo "source ~/.pyodibel-complete.bash" >> ~/.bashrc
    
        # Generate zsh completion
        pyodibel completion --shell zsh > ~/.pyodibel-complete.zsh
        echo "source ~/.pyodibel-complete.zsh" >> ~/.zshrc
    
        # Generate fish completion
        pyodibel completion --shell fish -o ~/.config/fish/completions/pyodibel.fish
    
    After generating, restart your shell or source the completion script.
    """
    shell_lower = shell.lower()
    
    # Click 8.0+ uses _<PROG_NAME>_COMPLETE environment variable
    # We generate a script that uses Click's built-in completion
    if shell_lower == "bash":
        script = """# Bash completion for pyodibel
# Generated by: pyodibel completion --shell bash
# Source this file in your ~/.bashrc or ~/.bash_profile

eval "$(_PYODIBEL_COMPLETE=bash_source pyodibel)"
"""
    elif shell_lower == "zsh":
        script = """# Zsh completion for pyodibel
# Generated by: pyodibel completion --shell zsh
# Source this file in your ~/.zshrc

eval "$(_PYODIBEL_COMPLETE=zsh_source pyodibel)"
"""
    elif shell_lower == "fish":
        script = """# Fish completion for pyodibel
# Generated by: pyodibel completion --shell fish
# Place this file in ~/.config/fish/completions/pyodibel.fish

eval (env _PYODIBEL_COMPLETE=fish_source pyodibel)
"""
    else:
        click.echo(f"Unsupported shell: {shell}", err=True)
        sys.exit(1)
    
    if output:
        try:
            with open(output, "w") as f:
                f.write(script)
            click.echo(f"Completion script written to {output}", err=True)
            click.echo(f"\nTo enable completion:", err=True)
            if shell_lower == "fish":
                click.echo(f"  The file has been written. Restart fish shell.", err=True)
            else:
                click.echo(f"  Add this line to your ~/.{shell_lower}rc:", err=True)
                click.echo(f"  source {output}", err=True)
                click.echo(f"\n  Or run now:", err=True)
                click.echo(f"  source {output}", err=True)
        except IOError as e:
            click.echo(f"Error writing to {output}: {e}", err=True)
            sys.exit(1)
    else:
        click.echo(script)


if __name__ == "__main__":
    cli() 